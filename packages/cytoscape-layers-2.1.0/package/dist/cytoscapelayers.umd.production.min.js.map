{"version":3,"file":"cytoscapelayers.umd.production.min.js","sources":["../src/layers/utils.ts","../src/layers/ABaseLayer.ts","../src/layers/ADOMBaseLayer.ts","../src/layers/SVGLayer.ts","../src/layers/CanvasLayer.ts","../src/layers/HTMLLayer.ts","../src/layers/CytoscapeLayer.ts","../src/elements/utils.ts","../src/elements/common.ts","../src/elements/edges.ts","../src/elements/nodes.ts","../src/LayersPlugin.ts","../src/index.ts"],"sourcesContent":["export const layerStyle: Partial<CSSStyleDeclaration> = {\n  position: 'absolute',\n  left: '0',\n  top: '0',\n  userSelect: 'none',\n  outlineStyle: 'none',\n  width: '100%',\n  height: '100%',\n};\n\nfunction stop(e: Event) {\n  e.stopPropagation();\n}\n\nexport function stopClicks(node: SVGElement | HTMLElement) {\n  node.addEventListener('click', stop);\n  node.addEventListener('mousedown', stop);\n  node.addEventListener('mouseup', stop);\n  node.addEventListener('mousemove', stop);\n}\n","import {\n  ICanvasLayer,\n  IHTMLLayer,\n  IMoveAbleLayer,\n  ISVGLayer,\n  ILayer,\n  IHTMLStaticLayer,\n  ISVGStaticLayer,\n  ICanvasStaticLayer,\n} from './interfaces';\nimport cy from 'cytoscape';\nimport { ICanvasLayerOptions, ISVGLayerOptions, IHTMLLayerOptions } from './public';\n\nexport interface ILayerAdapter {\n  cy: cy.Core;\n  move(layer: IMoveAbleLayer, offset: number): void;\n  insert(\n    where: 'before' | 'after',\n    layer: IMoveAbleLayer,\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ICanvasLayerOptions | ISVGLayerOptions\n  ): ILayer;\n  inVisibleBounds(p: { x: number; y: number } | cy.BoundingBox12): boolean;\n}\n\nexport abstract class ABaseLayer implements IMoveAbleLayer {\n  private updateOnRenderEnabled = false;\n\n  constructor(private readonly adapter: ILayerAdapter) {}\n\n  inVisibleBounds(p: { x: number; y: number } | cy.BoundingBox12) {\n    return this.adapter.inVisibleBounds(p);\n  }\n\n  get updateOnRender() {\n    return this.updateOnRenderEnabled;\n  }\n\n  set updateOnRender(value: boolean) {\n    if (this.updateOnRenderEnabled === value) {\n      return;\n    }\n    this.updateOnRenderEnabled = value;\n    if (value) {\n      this.cy.on('render', this.update);\n    } else {\n      this.cy.off('render', undefined, this.update);\n    }\n  }\n\n  abstract readonly update: () => void;\n\n  get cy() {\n    return this.adapter.cy;\n  }\n\n  moveUp() {\n    this.adapter.move(this, -1);\n  }\n  moveDown() {\n    this.adapter.move(this, 1);\n  }\n  moveBack() {\n    this.adapter.move(this, Number.NEGATIVE_INFINITY);\n  }\n  moveFront() {\n    this.adapter.move(this, Number.POSITIVE_INFINITY);\n  }\n\n  insertBefore(type: 'svg', options?: ISVGLayerOptions): ISVGLayer;\n  insertBefore(type: 'svg-static', options?: ISVGLayerOptions): ISVGStaticLayer;\n  insertBefore(type: 'canvas', options?: ICanvasLayerOptions): ICanvasLayer;\n  insertBefore(type: 'canvas-static', options?: ICanvasLayerOptions): ICanvasStaticLayer;\n  insertBefore(type: 'html', options?: IHTMLLayerOptions): IHTMLLayer;\n  insertBefore(type: 'html-static', options?: IHTMLLayerOptions): IHTMLStaticLayer;\n  insertBefore(\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ) {\n    return this.adapter.insert('before', this, type, options);\n  }\n\n  insertAfter(type: 'svg', options?: ISVGLayerOptions): ISVGLayer;\n  insertAfter(type: 'svg-static', options?: ISVGLayerOptions): ISVGStaticLayer;\n  insertAfter(type: 'canvas', options?: ICanvasLayerOptions): ICanvasLayer;\n  insertAfter(type: 'canvas-static', options?: ICanvasLayerOptions): ICanvasStaticLayer;\n  insertAfter(type: 'html', options?: IHTMLLayerOptions): IHTMLLayer;\n  insertAfter(type: 'html-static', options?: IHTMLLayerOptions): IHTMLStaticLayer;\n  insertAfter(\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ) {\n    return this.adapter.insert('after', this, type, options);\n  }\n}\n","import { ILayerElement } from './interfaces';\nimport { IDOMUpdateFunction } from './public';\nimport { layerStyle } from './utils';\nimport { ABaseLayer, ILayerAdapter } from './ABaseLayer';\n\nexport abstract class ADOMBaseLayer<T extends HTMLElement | SVGElement> extends ABaseLayer {\n  readonly root: T & ILayerElement;\n  readonly callbacks: IDOMUpdateFunction<T>[] = [];\n\n  constructor(adapter: ILayerAdapter, root: T) {\n    super(adapter);\n    this.root = (root as unknown) as T & ILayerElement;\n    Object.assign(this.root.style, layerStyle);\n  }\n\n  abstract get node(): T;\n\n  readonly update = () => {\n    for (const o of this.callbacks) {\n      o(this.node);\n    }\n  };\n\n  get visible() {\n    return this.root.style.display !== 'none';\n  }\n\n  set visible(value: boolean) {\n    if (this.visible == value) {\n      return;\n    }\n    this.root.style.display = value ? '' : 'none';\n  }\n\n  show() {\n    this.visible = true;\n  }\n  hide() {\n    this.visible = false;\n  }\n\n  callback(callback: IDOMUpdateFunction<T>) {\n    this.callbacks.push(callback);\n    this.update();\n    return this;\n  }\n\n  resize() {\n    // dummy\n  }\n\n  remove() {\n    this.root.remove();\n  }\n}\n","import { ILayerAdapter } from './ABaseLayer';\nimport { ADOMBaseLayer } from './ADOMBaseLayer';\nimport { ILayerElement, ILayerImpl, ISVGLayer, ISVGStaticLayer } from './interfaces';\nimport { ISVGLayerOptions } from './public';\nimport { stopClicks } from './utils';\n\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\n\nexport class SVGLayer extends ADOMBaseLayer<SVGElement> implements ISVGLayer, ILayerImpl {\n  readonly type = 'svg';\n  readonly node: SVGGElement & ILayerElement;\n  updateOnTransform = false;\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: ISVGLayerOptions = {}) {\n    super(adapter, doc.createElementNS(SVG_NS, 'svg'));\n    this.root.__cy_layer = this;\n    this.node = (doc.createElementNS(SVG_NS, 'g') as unknown) as SVGGElement & ILayerElement;\n    this.node.__cy_layer = this;\n    this.root.appendChild(this.node);\n    if (options.stopClicks) {\n      stopClicks(this.node);\n    }\n  }\n\n  setViewport(tx: number, ty: number, zoom: number) {\n    this.node.setAttribute('transform', `translate(${tx},${ty})scale(${zoom})`);\n    if (this.updateOnTransform) {\n      this.update();\n    }\n  }\n}\n\nexport class SVGStaticLayer extends ADOMBaseLayer<SVGElement> implements ISVGStaticLayer, ILayerImpl {\n  readonly type = 'svg-static';\n  readonly node: SVGGElement & ILayerElement;\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: ISVGLayerOptions = {}) {\n    super(adapter, doc.createElementNS(SVG_NS, 'svg'));\n    this.root.__cy_layer = this;\n    this.node = (doc.createElementNS(SVG_NS, 'g') as unknown) as SVGGElement & ILayerElement;\n    this.node.__cy_layer = this;\n    this.root.appendChild(this.node);\n    if (options.stopClicks) {\n      stopClicks(this.node);\n    }\n  }\n\n  setViewport() {\n    // dummy\n  }\n}\n","import { ICanvasLayer, ILayerElement, ILayerImpl, IRenderFunction, ICanvasStaticLayer } from './interfaces';\nimport { layerStyle, stopClicks } from './utils';\nimport { ABaseLayer, ILayerAdapter } from './ABaseLayer';\nimport { ICanvasLayerOptions } from './public';\n\nexport class CanvasBaseLayer extends ABaseLayer implements ILayerImpl {\n  readonly node: HTMLCanvasElement & ILayerElement;\n  readonly ctx: CanvasRenderingContext2D;\n  protected readonly pixelRatio: number;\n  readonly callbacks: IRenderFunction[] = [];\n  protected readonly transform: { tx: number; ty: number; zoom: number } = {\n    tx: 0,\n    ty: 0,\n    zoom: 1,\n  };\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: ICanvasLayerOptions = {}) {\n    super(adapter);\n    this.node = (doc.createElement('canvas') as unknown) as HTMLCanvasElement & ILayerElement;\n    Object.assign(this.node.style, layerStyle);\n    if (options.stopClicks) {\n      stopClicks(this.node);\n    }\n    this.pixelRatio = options.pixelRatio ?? (window ?? {}).devicePixelRatio ?? 1;\n    this.ctx = this.node.getContext('2d', options)!;\n    this.ctx.resetTransform();\n  }\n\n  get visible() {\n    return this.node.style.display !== 'none';\n  }\n\n  set visible(value: boolean) {\n    this.node.style.display = value ? '' : 'none';\n  }\n  show() {\n    this.visible = true;\n  }\n  hide() {\n    this.visible = false;\n  }\n\n  get root() {\n    return this.node;\n  }\n\n  callback(callback: IRenderFunction) {\n    this.callbacks.push(callback);\n    this.update();\n    return this;\n  }\n\n  readonly update = () => this.draw();\n\n  clear() {\n    const ctx = this.ctx;\n    const bak = ctx.getTransform();\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.setTransform(bak);\n  }\n\n  draw() {\n    this.clear();\n    this.ctx.save();\n    this.ctx.resetTransform();\n    this.ctx.scale(this.pixelRatio, this.pixelRatio);\n    this.ctx.translate(this.transform.tx, this.transform.ty);\n    this.ctx.scale(this.transform.zoom, this.transform.zoom);\n\n    for (const r of this.callbacks) {\n      r(this.ctx);\n    }\n\n    this.ctx.restore();\n  }\n\n  resize(width: number, height: number) {\n    this.node.width = width * this.pixelRatio;\n    this.node.height = height * this.pixelRatio;\n    this.update();\n  }\n\n  setViewport(_tx: number, _ty: number, _zoom: number) {\n    // dummy\n  }\n\n  remove() {\n    this.node.remove();\n  }\n}\n\nexport class CanvasLayer extends CanvasBaseLayer implements ICanvasLayer {\n  readonly type = 'canvas';\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: ICanvasLayerOptions = {}) {\n    super(adapter, doc, options);\n    this.node.__cy_layer = this;\n  }\n\n  setViewport(tx: number, ty: number, zoom: number) {\n    this.transform.tx = tx;\n    this.transform.ty = ty;\n    this.transform.zoom = zoom;\n    this.update();\n  }\n}\n\nexport class CanvasStaticLayer extends CanvasBaseLayer implements ICanvasStaticLayer {\n  readonly type = 'canvas-static';\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: ICanvasLayerOptions = {}) {\n    super(adapter, doc, options);\n    this.node.__cy_layer = this;\n  }\n}\n","import { ILayerAdapter } from './ABaseLayer';\nimport { ADOMBaseLayer } from './ADOMBaseLayer';\nimport { IHTMLLayer, IHTMLStaticLayer, ILayerElement, ILayerImpl } from './interfaces';\nimport { IHTMLLayerOptions } from './public';\nimport { stopClicks } from './utils';\n\nexport class HTMLLayer extends ADOMBaseLayer<HTMLElement> implements IHTMLLayer, ILayerImpl {\n  readonly type = 'html';\n  readonly node: HTMLDivElement & ILayerElement;\n  updateOnTransform = false;\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: IHTMLLayerOptions = {}) {\n    super(adapter, doc.createElement('div'));\n    this.root.__cy_layer = this;\n    this.node = (doc.createElement('div') as unknown) as HTMLDivElement & ILayerElement;\n    this.node.__cy_layer = this;\n    this.node.style.position = 'absolute';\n    this.node.style.left = '0px';\n    this.node.style.top = '0px';\n    this.root.appendChild(this.node);\n    if (options.stopClicks) {\n      stopClicks(this.node);\n    }\n  }\n\n  setViewport(tx: number, ty: number, zoom: number) {\n    this.node.style.transform = `translate(${tx}px,${ty}px)scale(${zoom})`;\n    if (this.updateOnTransform) {\n      this.update();\n    }\n  }\n}\n\nexport class HTMLStaticLayer extends ADOMBaseLayer<HTMLElement> implements IHTMLStaticLayer, ILayerImpl {\n  readonly type = 'html-static';\n\n  constructor(adapter: ILayerAdapter, doc: Document, options: IHTMLLayerOptions = {}) {\n    super(adapter, doc.createElement('div'));\n    this.node.__cy_layer = this;\n    if (options.stopClicks) {\n      stopClicks(this.node);\n    }\n  }\n\n  get node() {\n    return this.root;\n  }\n\n  setViewport() {\n    // dummy\n  }\n}\n","import { ABaseLayer, ILayerAdapter } from './ABaseLayer';\nimport {\n  ICytoscapeDragLayer,\n  ICytoscapeNodeLayer,\n  ICytoscapeSelectBoxLayer,\n  ILayerElement,\n  ILayerImpl,\n} from './interfaces';\n\nexport class CytoscapeBaseLayer extends ABaseLayer implements ILayerImpl {\n  readonly node: HTMLCanvasElement & ILayerElement;\n\n  constructor(adapter: ILayerAdapter, node: HTMLCanvasElement) {\n    super(adapter);\n    this.node = (node as unknown) as HTMLCanvasElement & ILayerElement;\n  }\n\n  get root() {\n    return this.node;\n  }\n\n  readonly update = () => {};\n\n  resize() {}\n\n  setViewport() {}\n\n  remove() {}\n}\n\nexport class CytoscapeNodeLayer extends CytoscapeBaseLayer implements ICytoscapeNodeLayer {\n  readonly type = 'node';\n\n  constructor(adapter: ILayerAdapter, node: HTMLCanvasElement) {\n    super(adapter, node);\n    this.node.__cy_layer = this;\n  }\n}\n\nexport class CytoscapeDragLayer extends CytoscapeBaseLayer implements ICytoscapeDragLayer {\n  readonly type = 'drag';\n\n  constructor(adapter: ILayerAdapter, node: HTMLCanvasElement) {\n    super(adapter, node);\n    this.node.__cy_layer = this;\n  }\n}\n\nexport class CytoscapeSelectBoxLayer extends CytoscapeBaseLayer implements ICytoscapeSelectBoxLayer {\n  readonly type = 'select-box';\n\n  constructor(adapter: ILayerAdapter, node: HTMLCanvasElement) {\n    super(adapter, node);\n    this.node.__cy_layer = this;\n  }\n}\n","import cy from 'cytoscape';\n\nexport interface IMatchOptions<T extends HTMLElement | SVGElement> {\n  bb: (node: cy.NodeSingular) => cy.BoundingBox12 & cy.BoundingBoxWH;\n  isVisible: (bb: cy.BoundingBox12 & cy.BoundingBoxWH) => boolean;\n  enter: (node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => T;\n  update: (elem: T, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => void;\n  uniqueElements: boolean;\n}\n\nexport function matchNodes<T extends HTMLElement | SVGElement>(\n  root: T,\n  nodes: cy.NodeCollection,\n  options: IMatchOptions<T>\n) {\n  const arr = Array.from(root.children) as T[];\n  if (!options.uniqueElements) {\n    nodes.forEach((node) => {\n      const bb = options.bb(node);\n      if (!options.isVisible(bb)) {\n        return;\n      }\n      if (arr.length > 0) {\n        options.update(arr.shift()!, node, bb);\n      } else {\n        const elem = options.enter(node, bb);\n        root.appendChild(elem);\n        options.update(elem, node, bb);\n      }\n    });\n    for (const rest of arr) {\n      rest.remove();\n    }\n    return;\n  }\n  // match\n  const map = new Map(arr.map((d) => [d.dataset.id!, d] as [string, T]));\n\n  let i = -1;\n  nodes.forEach((node) => {\n    const bb = options.bb(node);\n    if (!options.isVisible(bb)) {\n      return;\n    }\n    i++;\n    const id = node.id();\n    const expected = arr[i];\n    const has = map.get(id);\n    let n: T;\n    if (has) {\n      options.update(has, node, bb);\n      map.delete(id);\n      if (expected === has) {\n        // match 1:1\n        return;\n      }\n      n = has;\n    } else {\n      // need a new one\n      n = options.enter(node, bb);\n      n.dataset.id = id;\n      options.update(n, node, bb);\n    }\n\n    if (i === 0) {\n      root.insertAdjacentElement('afterbegin', n);\n    } else {\n      arr[i - 1].insertAdjacentElement('afterend', n);\n    }\n    arr.splice(i, 0, n);\n  });\n  // delete rest\n  map.forEach((n) => n.remove());\n}\n\nexport interface ICallbackRemover {\n  remove(): void;\n}\n\nexport function registerCallback<U, T extends { callback(c: U): void; callbacks: U[] }>(\n  layer: T,\n  renderer: U\n): ICallbackRemover {\n  layer.callback(renderer);\n  return {\n    remove: () => {\n      layer.callbacks.splice(layer.callbacks.indexOf(renderer), 1);\n    },\n  };\n}\n","export interface IElementLayerOptions {\n  /**\n   * selector to determine elements to render\n   * @default :visible\n   */\n  selector: string;\n  /**\n   * whether to update the collection on each update\n   */\n  queryEachTime: boolean;\n  /**\n   * automatically update the layer upon a certain event\n   * @default auto = render in case of a queryEachTime else position\n   */\n  updateOn: 'render' | 'position' | 'none';\n\n  /**\n   * whether to check that the element is actually visible\n   * @default true\n   */\n  checkBounds: boolean;\n}\n\nexport function defaultElementLayerOptions(o?: Partial<IElementLayerOptions>): IElementLayerOptions {\n  return {\n    selector: ':visible',\n    updateOn: o != null && o.queryEachTime ? 'render' : 'position',\n    queryEachTime: false,\n    checkBounds: true,\n  };\n}\n","import cy from 'cytoscape';\nimport { ICanvasLayer, IPoint } from '../layers';\nimport { ICallbackRemover, registerCallback } from './utils';\nimport { IElementLayerOptions, defaultElementLayerOptions } from './common';\n\nexport interface IRenderPerEdgeResult extends ICallbackRemover {\n  layer: ICanvasLayer;\n  edges: cy.EdgeCollection;\n}\n\nexport interface IEdgeLayerOptions extends IElementLayerOptions {\n  checkBoundsPointCount: number;\n  /**\n   * init function for the collection\n   * @param edges\n   */\n  initCollection(edges: cy.EdgeCollection): void;\n}\n\nexport function renderPerEdge(\n  layer: ICanvasLayer,\n  render: (ctx: CanvasRenderingContext2D, edge: cy.EdgeSingular, path: Path2D, start: IPoint, end: IPoint) => void,\n  options?: Partial<IEdgeLayerOptions>\n): IRenderPerEdgeResult {\n  const o: IEdgeLayerOptions = Object.assign(\n    {\n      checkBoundsPointCount: 5,\n      initCollection: () => undefined,\n    },\n    defaultElementLayerOptions(options),\n    options\n  );\n  const edges = o.queryEachTime ? layer.cy.collection() : layer.cy.edges(o.selector);\n  if (!o.queryEachTime) {\n    o.initCollection(edges);\n  }\n\n  if (o.updateOn === 'render') {\n    layer.updateOnRender = true;\n  } else if (o.updateOn === 'position') {\n    edges.on('position add remove', layer.update);\n    edges.sources().on('position', layer.update);\n    edges.targets().on('position', layer.update);\n  } else {\n    edges.on('add remove', layer.update);\n  }\n\n  const renderer = (ctx: CanvasRenderingContext2D) => {\n    const currentEdges = o.queryEachTime ? layer.cy.edges(o.selector) : edges;\n    if (o.queryEachTime) {\n      o.initCollection(currentEdges);\n    }\n    currentEdges.forEach((edge) => {\n      const impl = (edge as any)._private.rscratch as {\n        pathCache: Path2D;\n        startX?: number;\n        startY?: number;\n        endX?: number;\n        endY?: number;\n      };\n      const s =\n        impl && impl.startX != null && impl.startY != null ? { x: impl.startX, y: impl.startY } : edge.sourceEndpoint();\n      const t = impl && impl.endX != null && impl.endY != null ? { x: impl.endX, y: impl.endY } : edge.targetEndpoint();\n\n      if (o.checkBounds && o.checkBoundsPointCount > 0 && !anyVisible(layer, s, t, o.checkBoundsPointCount)) {\n        return;\n      }\n      if (impl && impl.pathCache) {\n        render(ctx, edge, impl.pathCache, s, t);\n        return;\n      }\n      const path = new Path2D();\n      path.moveTo(s.x, s.y);\n      path.lineTo(t.x, t.y);\n      render(ctx, edge, path, s, t);\n    });\n  };\n\n  const r = registerCallback(layer, renderer);\n  return {\n    layer,\n    edges,\n    remove: () => {\n      edges.off('position add remove', undefined, layer.update);\n      edges.sources().off('position', undefined, layer.update);\n      edges.targets().off('position', undefined, layer.update);\n      r.remove();\n    },\n  };\n}\n\nfunction anyVisible(layer: ICanvasLayer, s: IPoint, t: IPoint, count: number) {\n  const interpolate = (v: number) => ({\n    x: s.x * v + t.x * (1 - v),\n    y: s.y * v + t.y * (1 - v),\n  });\n  if (count === 1) {\n    return layer.inVisibleBounds(interpolate(0.5));\n  }\n  const step = 1 / count;\n  for (let i = 0; i <= count; i++) {\n    if (layer.inVisibleBounds(interpolate(i * step))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import cy from 'cytoscape';\nimport { ICanvasLayer, IHTMLLayer, ISVGLayer, ILayer } from '../layers';\nimport { SVG_NS } from '../layers/SVGLayer';\nimport { matchNodes, registerCallback, ICallbackRemover, IMatchOptions } from './utils';\nimport { IElementLayerOptions, defaultElementLayerOptions } from './common';\n\nexport interface INodeLayerOption extends IElementLayerOptions {\n  /**\n   * how to compute the bounding box\n   */\n  boundingBox: cy.BoundingBoxOptions;\n  /**\n   * where to position the canvas / node relative to a node\n   */\n  position: 'none' | 'top-left' | 'center';\n  /**\n   * init function for the collection\n   * @param nodes\n   */\n  initCollection(nodes: cy.NodeCollection): void;\n}\n\nexport interface INodeDOMLayerOption<T extends HTMLElement | SVGElement> extends INodeLayerOption {\n  /**\n   * whether to use unique DOM elements per node (id), similar to D3 key argument\n   * @default false\n   */\n  uniqueElements: boolean;\n  /**\n   * init function for newly created DOM elements\n   * @param elem\n   * @param node\n   */\n  init(elem: T, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH): void;\n\n  /**\n   * additional transform to apply to a node\n   */\n  transform?: string;\n}\n\nexport interface INodeCanvasLayerOption extends INodeLayerOption {\n  /**\n   * init function for newly added node\n   * @param elem\n   * @param node\n   */\n  init(node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH): void;\n}\n\nexport interface IRenderPerNodeResult extends ICallbackRemover {\n  layer: ILayer;\n  nodes: cy.NodeCollection;\n}\n\nexport function renderPerNode(\n  layer: ICanvasLayer,\n  render: (ctx: CanvasRenderingContext2D, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => void,\n  options?: Partial<INodeCanvasLayerOption>\n): IRenderPerNodeResult;\nexport function renderPerNode(\n  layer: IHTMLLayer,\n  render: (elem: HTMLElement, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => void,\n  options?: Partial<INodeDOMLayerOption<HTMLElement>>\n): IRenderPerNodeResult;\nexport function renderPerNode(\n  layer: ISVGLayer,\n  render: (elem: SVGElement, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => void,\n  options?: Partial<INodeDOMLayerOption<SVGElement>>\n): IRenderPerNodeResult;\nexport function renderPerNode(\n  layer: ICanvasLayer | IHTMLLayer | ISVGLayer,\n  render: (ctx: any, node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => void,\n  options: Partial<INodeDOMLayerOption<any> | INodeCanvasLayerOption> = {}\n): IRenderPerNodeResult {\n  const o = Object.assign(\n    {\n      transform: '',\n      position: 'top-left',\n      boundingBox: {\n        includeLabels: false,\n        includeOverlays: false,\n      },\n      uniqueElements: false,\n      initCollection: () => undefined,\n    },\n    defaultElementLayerOptions(options),\n    options\n  );\n  const nodes = o.queryEachTime ? layer.cy.collection() : layer.cy.nodes(o.selector);\n  if (!o.queryEachTime) {\n    o.initCollection(nodes);\n  }\n  if (o.updateOn === 'render') {\n    layer.updateOnRender = true;\n  } else if (o.updateOn === 'position') {\n    nodes.on('position add remove', layer.update);\n  } else {\n    nodes.on('add remove', layer.update);\n  }\n\n  const wrapResult = (v: ICallbackRemover): IRenderPerNodeResult => ({\n    layer,\n    nodes,\n    remove: () => {\n      nodes.off('position add remove', undefined, layer.update);\n      v.remove();\n    },\n  });\n\n  if (layer.type === 'canvas') {\n    const oCanvas = o as INodeCanvasLayerOption;\n    const renderer = (ctx: CanvasRenderingContext2D) => {\n      const t = ctx.getTransform();\n      const currentNodes = oCanvas.queryEachTime ? layer.cy.nodes(oCanvas.selector) : nodes;\n      if (o.queryEachTime) {\n        o.initCollection(currentNodes);\n      }\n      currentNodes.forEach((node) => {\n        const bb = node.boundingBox(o.boundingBox);\n        if (oCanvas.checkBounds && !layer.inVisibleBounds(bb)) {\n          return;\n        }\n        if (oCanvas.position === 'top-left') {\n          ctx.translate(bb.x1, bb.y1);\n        } else if (oCanvas.position === 'center') {\n          const pos = node.position();\n          ctx.translate(pos.x, pos.y);\n        }\n        render(ctx, node, bb);\n        if (oCanvas.position !== 'none') {\n          ctx.setTransform(t);\n        }\n      });\n    };\n    return wrapResult(registerCallback(layer, renderer));\n  }\n\n  const oDOM = o as INodeDOMLayerOption<any>;\n  // HTML or SVG\n  const baseOptions = {\n    bb: (node: cy.NodeSingular) => node.boundingBox(oDOM.boundingBox),\n    isVisible: oDOM.checkBounds ? (bb: cy.BoundingBox12 & cy.BoundingBoxWH) => layer.inVisibleBounds(bb) : () => true,\n    uniqueElements: oDOM.uniqueElements === true,\n  };\n  if (oDOM.checkBounds) {\n    layer.updateOnTransform = true;\n  }\n\n  if (layer.type === 'html') {\n    const matchOptions: IMatchOptions<HTMLElement> = {\n      ...baseOptions,\n      enter: (node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => {\n        const r = layer.node.ownerDocument.createElement('div');\n        r.style.position = 'absolute';\n        if (oDOM.init) {\n          oDOM.init(r, node, bb);\n        }\n        return r;\n      },\n      update: (elem, node, bb) => {\n        if (oDOM.position === 'top-left') {\n          elem.style.transform = `${oDOM.transform}translate(${bb.x1}px,${bb.y1}px)`;\n        } else if (oDOM.position === 'center') {\n          const pos = node.position();\n          elem.style.transform = `${oDOM.transform}translate(${pos.x}px,${pos.y}px)`;\n        }\n        render(elem, node, bb);\n      },\n    };\n    const renderer = (root: HTMLElement) => {\n      const currentNodes = oDOM.queryEachTime ? layer.cy.nodes(oDOM.selector) : nodes;\n      if (o.queryEachTime) {\n        o.initCollection(currentNodes);\n      }\n      matchNodes(root, currentNodes, matchOptions);\n    };\n    return wrapResult(registerCallback(layer, renderer));\n  }\n\n  // if (layer.type === 'svg') {\n  const matchOptions: IMatchOptions<SVGElement> = {\n    ...baseOptions,\n    enter: (node: cy.NodeSingular, bb: cy.BoundingBox12 & cy.BoundingBoxWH) => {\n      const r = layer.node.ownerDocument.createElementNS(SVG_NS, 'g');\n      if (oDOM.init) {\n        oDOM.init(r, node, bb);\n      }\n      return r;\n    },\n    update: (elem, node, bb) => {\n      if (oDOM.position === 'top-left') {\n        elem.setAttribute('transform', `${oDOM.transform}translate(${bb.x1},${bb.y1})`);\n      } else if (oDOM.position === 'center') {\n        const pos = node.position();\n        elem.setAttribute('transform', `${oDOM.transform}translate(${pos.x},${pos.y})`);\n      }\n      render(elem, node, bb);\n    },\n  };\n  const renderer = (root: SVGElement) => {\n    const currentNodes = oDOM.queryEachTime ? layer.cy.nodes(oDOM.selector) : nodes;\n    if (o.queryEachTime) {\n      o.initCollection(currentNodes);\n    }\n    matchNodes(root, currentNodes, matchOptions);\n  };\n  return wrapResult(registerCallback(layer, renderer));\n}\n","import cy from 'cytoscape';\nimport {\n  HTMLLayer,\n  ICytoscapeDragLayer,\n  ICytoscapeNodeLayer,\n  ICytoscapeSelectBoxLayer,\n  ILayer,\n  ISVGLayer,\n  ICanvasLayer,\n  IHTMLLayer,\n  CytoscapeNodeLayer,\n  CytoscapeDragLayer,\n  CytoscapeSelectBoxLayer,\n  ILayerImpl,\n  ILayerElement,\n  CanvasLayer,\n  SVGLayer,\n  IMoveAbleLayer,\n  SVGStaticLayer,\n  HTMLStaticLayer,\n  ISVGStaticLayer,\n  IHTMLStaticLayer,\n  CanvasStaticLayer,\n  ICanvasStaticLayer,\n  IHTMLLayerOptions,\n  ISVGLayerOptions,\n  ICanvasLayerOptions,\n  IPoint,\n} from './layers';\nimport { ILayerAdapter } from './layers/ABaseLayer';\nimport { renderPerEdge, renderPerNode } from './elements';\n\nfunction isPoint(p: IPoint | cy.BoundingBox12): p is IPoint {\n  return (p as IPoint).x != null;\n}\n\nexport default class LayersPlugin {\n  readonly cy: cy.Core;\n\n  readonly nodeLayer: ICytoscapeNodeLayer;\n  readonly dragLayer: ICytoscapeDragLayer;\n  readonly selectBoxLayer: ICytoscapeSelectBoxLayer;\n\n  private readonly adapter: ILayerAdapter;\n\n  private readonly viewport: { width: number; height: number; tx: number; ty: number; zoom: number };\n\n  constructor(cy: cy.Core) {\n    this.cy = cy;\n    this.adapter = {\n      cy: this.cy,\n      insert: (where: 'before' | 'after', layer: IMoveAbleLayer, type) =>\n        this.insert(where, layer as ILayer & ILayerImpl, type),\n      move: (layer: IMoveAbleLayer, offset) => this.move(layer as ILayer & ILayerImpl, offset),\n      inVisibleBounds: (p: IPoint | cy.BoundingBox12) => {\n        const v = this.viewport;\n        const inX = (x: number) => {\n          const xp = x * v.zoom + v.tx;\n          return xp >= 0 && xp <= v.width;\n        };\n        const inY = (y: number) => {\n          const yp = y * v.zoom + v.ty;\n          return yp >= 0 && yp <= v.height;\n        };\n        if (isPoint(p)) {\n          return inX(p.x) && inY(p.y);\n        }\n        // any of the four corners or the center are inside\n        return (\n          (inX(p.x1) && inY(p.y1)) ||\n          (inX(p.x2) && inY(p.y1)) ||\n          (inX(p.x2) && inY(p.y2)) ||\n          (inX(p.x1) && inY(p.y2)) ||\n          (inX((p.x1 + p.x2) / 2) && inY((p.y1 + p.y2) / 2))\n        );\n      },\n    };\n\n    const container = cy.container()!;\n\n    const nodeLayer = new CytoscapeNodeLayer(\n      this.adapter,\n      container.querySelector<HTMLCanvasElement>('[data-id=\"layer2-node\"]')!\n    );\n    this.nodeLayer = nodeLayer;\n\n    const dragLayer = new CytoscapeDragLayer(\n      this.adapter,\n      container.querySelector<HTMLCanvasElement>('[data-id=\"layer1-drag\"]')!\n    );\n    this.dragLayer = dragLayer;\n\n    const selectBoxLayer = new CytoscapeSelectBoxLayer(\n      this.adapter,\n      container.querySelector<HTMLCanvasElement>('[data-id=\"layer0-selectbox\"]')!\n    );\n    this.selectBoxLayer = selectBoxLayer;\n\n    nodeLayer.root.style.zIndex = '';\n    dragLayer.root.style.zIndex = '';\n    selectBoxLayer.root.style.zIndex = '';\n    nodeLayer.root.insertAdjacentElement('afterend', dragLayer.root);\n    dragLayer.root.insertAdjacentElement('afterend', selectBoxLayer.root);\n\n    cy.on('viewport', this.zoomed);\n    cy.on('resize', this.resize);\n    cy.on('destroy', this.destroy);\n\n    this.viewport = {\n      width: this.cy.width(),\n      height: this.cy.height(),\n      tx: this.cy.pan().x,\n      ty: this.cy.pan().y,\n      zoom: this.cy.zoom(),\n    };\n  }\n\n  private move(layer: ILayer & ILayerImpl, offset: number) {\n    const l = this.layers;\n    const index = l.indexOf(layer);\n    const target = Math.max(Math.min(index + offset, l.length, 0));\n    if (target === index) {\n      return;\n    }\n    if (index >= l.length - 1) {\n      this.root.appendChild(layer.root);\n    } else {\n      this.root.insertBefore(layer.root, l[target].root);\n    }\n  }\n\n  get document() {\n    return this.cy.container()!.ownerDocument;\n  }\n\n  get root() {\n    return this.nodeLayer.node.parentElement! as HTMLElement;\n  }\n\n  private get layers(): readonly (ILayer & ILayerImpl)[] {\n    return Array.from(this.root.children)\n      .map((d) => ((d as unknown) as ILayerElement).__cy_layer)\n      .filter((d) => d != null);\n  }\n\n  getLayers(): readonly ILayer[] {\n    return this.layers;\n  }\n\n  private readonly resize = () => {\n    const width = this.cy.width();\n    const height = this.cy.height();\n    this.viewport.width = width;\n    this.viewport.height = height;\n\n    for (const layer of this.layers) {\n      layer.resize(width, height);\n    }\n  };\n\n  private readonly destroy = () => {\n    for (const layer of this.layers) {\n      layer.remove();\n    }\n\n    this.cy.off('destroy', undefined, this.destroy);\n    this.cy.off('viewport', undefined, this.zoomed);\n    this.cy.off('resize', undefined, this.resize);\n    this.cy.scratch('_layers', undefined);\n  };\n\n  private readonly zoomed = () => {\n    const pan = this.cy.pan();\n    const zoom = this.cy.zoom();\n    this.viewport.tx = pan.x;\n    this.viewport.ty = pan.y;\n    this.viewport.zoom = zoom;\n\n    for (const layer of this.layers) {\n      layer.setViewport(pan.x, pan.y, zoom);\n    }\n  };\n\n  private init<T extends ILayer & ILayerImpl>(layer: T): T {\n    layer.resize(this.viewport.width, this.viewport.height);\n    layer.setViewport(this.viewport.tx, this.viewport.ty, this.viewport.zoom);\n    return layer;\n  }\n\n  update() {\n    this.zoomed();\n    for (const layer of this.layers) {\n      if (layer instanceof CanvasLayer) {\n        layer.draw();\n      }\n    }\n  }\n\n  private createLayer(\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ) {\n    switch (type) {\n      case 'svg':\n        return this.init(new SVGLayer(this.adapter, this.document, options));\n      case 'html':\n        return this.init(new HTMLLayer(this.adapter, this.document, options));\n      case 'canvas':\n        return this.init(new CanvasLayer(this.adapter, this.document, options));\n      case 'html-static':\n        return this.init(new HTMLStaticLayer(this.adapter, this.document, options));\n      case 'svg-static':\n        return this.init(new SVGStaticLayer(this.adapter, this.document, options));\n      case 'canvas-static':\n        return this.init(new CanvasStaticLayer(this.adapter, this.document, options));\n    }\n  }\n\n  append(type: 'svg', options?: ISVGLayerOptions): ISVGLayer;\n  append(type: 'svg-static', options?: ISVGLayerOptions): ISVGStaticLayer;\n  append(type: 'canvas', options?: ICanvasLayerOptions): ICanvasLayer;\n  append(type: 'canvas-static', options?: ICanvasLayerOptions): ICanvasStaticLayer;\n  append(type: 'html', options?: IHTMLLayerOptions): IHTMLLayer;\n  append(type: 'html-static', options?: IHTMLLayerOptions): IHTMLStaticLayer;\n  append(\n    type: 'svg' | 'html' | 'canvas' | 'canvas-static' | 'svg-static' | 'html-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ) {\n    const layer = this.createLayer(type, options);\n    this.root.appendChild(layer.root);\n    return layer as any;\n  }\n\n  insert(where: 'before' | 'after', layer: ILayer & ILayerImpl, type: 'svg', options?: ISVGLayerOptions): ISVGLayer;\n  insert(\n    where: 'before' | 'after',\n    layer: ILayer & ILayerImpl,\n    type: 'svg-static',\n    options?: ISVGLayerOptions\n  ): ISVGStaticLayer;\n  insert(\n    where: 'before' | 'after',\n    layer: ILayer & ILayerImpl,\n    type: 'canvas',\n    options?: ICanvasLayerOptions\n  ): ICanvasLayer;\n  insert(\n    where: 'before' | 'after',\n    layer: ILayer & ILayerImpl,\n    type: 'canvas-static',\n    options?: ICanvasLayerOptions\n  ): ICanvasStaticLayer;\n  insert(where: 'before' | 'after', layer: ILayer & ILayerImpl, type: 'html', options?: IHTMLLayerOptions): IHTMLLayer;\n  insert(\n    where: 'before' | 'after',\n    layer: ILayer & ILayerImpl,\n    type: 'html-static',\n    options?: IHTMLLayerOptions\n  ): IHTMLStaticLayer;\n  insert(\n    where: 'before' | 'after',\n    layer: ILayer & ILayerImpl,\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ): ISVGLayer | ICanvasLayer | IHTMLLayer;\n  insert(\n    where: 'before' | 'after',\n    ref: ILayer & ILayerImpl,\n    type: 'svg' | 'html' | 'canvas' | 'svg-static' | 'html-static' | 'canvas-static',\n    options?: IHTMLLayerOptions | ISVGLayerOptions | ICanvasLayerOptions\n  ) {\n    const layer = this.createLayer(type, options);\n    ref.root.insertAdjacentElement(where === 'before' ? 'beforebegin' : 'afterend', layer.root);\n    return layer as any;\n  }\n\n  getLast(): ILayer | null {\n    const layers = this.layers;\n    return layers[layers.length - 1] ?? null;\n  }\n\n  getFirst(): ILayer | null {\n    const layers = this.layers;\n    return layers[0] ?? null;\n  }\n\n  readonly renderPerEdge = renderPerEdge;\n  readonly renderPerNode = renderPerNode;\n}\n\nexport function layers(this: cy.Core): LayersPlugin;\nexport function layers(cy: cy.Core): LayersPlugin;\nexport function layers(this: cy.Core, cy: cy.Core = this) {\n  if (!cy.container()) {\n    throw new Error('layers plugin does not work in headless environments');\n  }\n  // ensure just one instance exists\n  const singleton = cy.scratch('_layers') as LayersPlugin;\n  if (singleton) {\n    return singleton;\n  }\n  const plugin = new LayersPlugin(cy);\n  cy.scratch('_layers', plugin);\n  return plugin;\n}\n","import { layers } from './LayersPlugin';\nexport * from './LayersPlugin';\nexport { default as LayersPlugin } from './LayersPlugin';\nexport * from './elements';\nexport * from './layers/public';\n\nexport default function register(\n  cytoscape: (type: 'core' | 'collection' | 'layout', name: string, extension: any) => void\n) {\n  cytoscape('core', 'layers', layers);\n}\n\n// auto register\nif (typeof (window as any).cytoscape !== 'undefined') {\n  register((window as any).cytoscape);\n}\n\nexport declare namespace cytoscape {\n  type Ext2 = (cytoscape: (type: 'core' | 'collection' | 'layout', name: string, extension: any) => void) => void;\n  function use(module: Ext2): void;\n\n  interface Core {\n    layers: typeof layers;\n  }\n}\n"],"names":["layerStyle","position","left","top","userSelect","outlineStyle","width","height","stop","e","stopPropagation","stopClicks","node","addEventListener","ABaseLayer","constructor","adapter","inVisibleBounds","p","this","updateOnRenderEnabled","value","cy","on","update","off","undefined","moveUp","move","moveDown","moveBack","Number","NEGATIVE_INFINITY","moveFront","POSITIVE_INFINITY","insertBefore","type","options","insert","insertAfter","ADOMBaseLayer","root","o","callbacks","Object","assign","style","display","visible","show","hide","callback","push","resize","remove","SVG_NS","SVGLayer","doc","createElementNS","__cy_layer","appendChild","setViewport","tx","ty","zoom","setAttribute","updateOnTransform","SVGStaticLayer","CanvasBaseLayer","draw","createElement","pixelRatio","window","devicePixelRatio","ctx","getContext","resetTransform","clear","bak","getTransform","clearRect","canvas","setTransform","save","scale","translate","transform","r","restore","_tx","_ty","_zoom","CanvasLayer","CanvasStaticLayer","HTMLLayer","HTMLStaticLayer","CytoscapeBaseLayer","CytoscapeNodeLayer","CytoscapeDragLayer","CytoscapeSelectBoxLayer","matchNodes","nodes","arr","Array","from","children","uniqueElements","forEach","bb","isVisible","length","shift","elem","enter","rest","map","Map","d","dataset","id","i","expected","has","get","n","delete","insertAdjacentElement","splice","registerCallback","layer","renderer","indexOf","defaultElementLayerOptions","selector","updateOn","queryEachTime","checkBounds","renderPerEdge","render","checkBoundsPointCount","initCollection","edges","collection","updateOnRender","sources","targets","currentEdges","edge","impl","_private","rscratch","s","startX","startY","x","y","sourceEndpoint","t","endX","endY","targetEndpoint","count","interpolate","v","step","anyVisible","pathCache","path","Path2D","moveTo","lineTo","renderPerNode","boundingBox","includeLabels","includeOverlays","wrapResult","oCanvas","currentNodes","x1","y1","pos","oDOM","baseOptions","matchOptions","ownerDocument","init","LayersPlugin","viewport","layers","destroy","zoomed","scratch","pan","where","offset","inX","xp","inY","yp","isPoint","x2","y2","container","nodeLayer","querySelector","dragLayer","selectBoxLayer","zIndex","l","index","target","Math","max","min","parentElement","filter","getLayers","createLayer","document","append","ref","getLast","getFirst","Error","singleton","plugin","register","cytoscape"],"mappings":"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"}