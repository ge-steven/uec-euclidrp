{"version":3,"file":"index.umd.min.js","sources":["../.yarn/cache/tslib-npm-2.0.3-62a2b3751d-447bfca5de.zip/node_modules/tslib/tslib.es6.js","../.yarn/cache/bubblesets-js-npm-2.2.0-438763805b-d132d8f6d5.zip/node_modules/bubblesets-js/dist/bubblesets.esm.js","../.yarn/cache/lodash.throttle-npm-4.1.1-856641af92-d9107c7903.zip/node_modules/lodash.throttle/index.js","../src/BubbleSetPath.ts","../src/BubbleSetsPlugin.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * bubblesets-js\n * https://github.com/upsetjs/bubblesets-js\n *\n * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>\n */\nfunction linePtSegDistSq(lx1, ly1, lx2, ly2, x, y) {\n  const x1 = lx1;\n  const y1 = ly1;\n  const x2 = lx2 - x1;\n  const y2 = ly2 - y1;\n  let px = x - x1;\n  let py = y - y1;\n  let dotprod = px * x2 + py * y2;\n  let projlenSq = 0;\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n  const lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    return 0;\n  }\n  return lenSq;\n}\nfunction ptsDistanceSq(x1, y1, x2, y2) {\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\nfunction doublePointsEqual(x1, y1, x2, y2, delta) {\n  return ptsDistanceSq(x1, y1, x2, y2) < delta * delta;\n}\nfunction round(digits) {\n  if (!Number.isFinite(digits)) {\n    return v => v;\n  }\n  if (digits === 0) {\n    return Math.round;\n  }\n  const factor = Math.pow(10, digits);\n  return v => Math.round(v * factor) / factor;\n}\n\nfunction lineBoundingBox(line) {\n  const minX = Math.min(line.x1, line.x2);\n  const maxX = Math.max(line.x1, line.x2);\n  const minY = Math.min(line.y1, line.y2);\n  const maxY = Math.max(line.y1, line.y2);\n  return {\n    x: minX,\n    y: minY,\n    x2: maxX,\n    y2: maxY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nclass Line {\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  equals(that) {\n    return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;\n  }\n  draw(ctx) {\n    ctx.moveTo(this.x1, this.y1);\n    ctx.lineTo(this.x2, this.y2);\n  }\n  toString() {\n    return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;\n  }\n  static from(l) {\n    return new Line(l.x1, l.y1, l.x2, l.y2);\n  }\n  cuts(px, py) {\n    if (this.y1 === this.y2) {\n      return false;\n    }\n    if (py < this.y1 && py <= this.y2 || py > this.y1 && py >= this.y2) {\n      return false;\n    }\n    if (px > this.x1 && px >= this.x2) {\n      return false;\n    }\n    if (px < this.x1 && px <= this.x2) {\n      return true;\n    }\n    const cross = this.x1 + (py - this.y1) * (this.x2 - this.x1) / (this.y2 - this.y1);\n    return px <= cross;\n  }\n  distSquare(x, y) {\n    return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x, y);\n  }\n  ptClose(x, y, r) {\n    if (this.x1 < this.x2) {\n      if (x < this.x1 - r || x > this.x2 + r) {\n        return false;\n      }\n    } else {\n      if (x < this.x2 - r || x > this.x1 + r) {\n        return false;\n      }\n    }\n    if (this.y1 < this.y2) {\n      if (y < this.y1 - r || y > this.y2 + r) {\n        return false;\n      }\n    } else {\n      if (y < this.y2 - r || y > this.y1 + r) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nvar EState;\n(function (EState) {\n  EState[EState[\"POINT\"] = 1] = \"POINT\";\n  EState[EState[\"PARALLEL\"] = 2] = \"PARALLEL\";\n  EState[EState[\"COINCIDENT\"] = 3] = \"COINCIDENT\";\n  EState[EState[\"NONE\"] = 4] = \"NONE\";\n})(EState || (EState = {}));\nclass Intersection {\n  constructor(state, x = 0, y = 0) {\n    this.state = state;\n    this.x = x;\n    this.y = y;\n  }\n}\nfunction intersectLineLine(la, lb) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));\n    }\n    return new Intersection(EState.NONE);\n  }\n  return new Intersection(uaT == 0 || ubT == 0 ? EState.COINCIDENT : EState.PARALLEL);\n}\nfunction fractionAlongLineA(la, lb) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return ua;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction hasFractionToLineCenter(bounds, line) {\n  function testLine(xa, ya, xb, yb) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      return 1;\n    }\n    return 0;\n  }\n  let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  return countIntersections > 0;\n}\nvar OUT_CODE;\n(function (OUT_CODE) {\n  OUT_CODE[OUT_CODE[\"LEFT\"] = 0] = \"LEFT\";\n  OUT_CODE[OUT_CODE[\"TOP\"] = 1] = \"TOP\";\n  OUT_CODE[OUT_CODE[\"RIGHT\"] = 2] = \"RIGHT\";\n  OUT_CODE[OUT_CODE[\"BOTTOM\"] = 3] = \"BOTTOM\";\n})(OUT_CODE || (OUT_CODE = {}));\nfunction outcode(bounds, px, py) {\n  const out = new Set();\n  if (bounds.width <= 0) {\n    out.add(OUT_CODE.LEFT);\n    out.add(OUT_CODE.RIGHT);\n  } else if (px < bounds.x) {\n    out.add(OUT_CODE.LEFT);\n  } else if (px > bounds.x + bounds.width) {\n    out.add(OUT_CODE.RIGHT);\n  }\n  if (bounds.height <= 0) {\n    out.add(OUT_CODE.TOP);\n    out.add(OUT_CODE.BOTTOM);\n  } else if (py < bounds.y) {\n    out.add(OUT_CODE.TOP);\n  } else if (py > bounds.y + bounds.height) {\n    out.add(OUT_CODE.BOTTOM);\n  }\n  return out;\n}\nfunction intersectsLine(bounds, line) {\n  let x1 = line.x1;\n  let y1 = line.y1;\n  let x2 = line.x2;\n  let y2 = line.y2;\n  const out2 = Array.from(outcode(bounds, x2, y2));\n  if (out2.length === 0) {\n    return true;\n  }\n  let out1 = outcode(bounds, x1, y1);\n  while (out1.size !== 0) {\n    if (out2.some(a => out1.has(a))) {\n      return false;\n    }\n    if (out1.has(OUT_CODE.RIGHT) || out1.has(OUT_CODE.LEFT)) {\n      let x = bounds.x;\n      if (out1.has(OUT_CODE.RIGHT)) {\n        x += bounds.width;\n      }\n      y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n      x1 = x;\n    } else {\n      let y = bounds.y;\n      if (out1.has(OUT_CODE.BOTTOM)) {\n        y += bounds.height;\n      }\n      x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n      y1 = y;\n    }\n    out1 = outcode(bounds, x1, y1);\n  }\n  return true;\n}\nfunction fractionToLineCenter(bounds, line) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let countIntersections = 0;\n  function testLine(xa, ya, xb, yb) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections++;\n      if (testDistance < minDistance) {\n        minDistance = testDistance;\n      }\n    }\n  }\n  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  if (countIntersections == 0) {\n    return -1;\n  }\n  return minDistance;\n}\nfunction testIntersection(line, bounds) {\n  let count = 0;\n  const top = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x2, bounds.y));\n  count += top.state === EState.POINT ? 1 : 0;\n  const left = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x, bounds.y2));\n  count += left.state === EState.POINT ? 1 : 0;\n  const bottom = intersectLineLine(line, new Line(bounds.x, bounds.y2, bounds.x2, bounds.y2));\n  count += bottom.state === EState.POINT ? 1 : 0;\n  const right = intersectLineLine(line, new Line(bounds.x2, bounds.y, bounds.x2, bounds.y2));\n  count += right.state === EState.POINT ? 1 : 0;\n  return {\n    top,\n    left,\n    bottom,\n    right,\n    count\n  };\n}\n\nclass Rectangle {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  get x2() {\n    return this.x + this.width;\n  }\n  get y2() {\n    return this.y + this.height;\n  }\n  get cx() {\n    return this.x + this.width / 2;\n  }\n  get cy() {\n    return this.y + this.height / 2;\n  }\n  get radius() {\n    return Math.max(this.width, this.height) / 2;\n  }\n  static from(r) {\n    return new Rectangle(r.x, r.y, r.width, r.height);\n  }\n  equals(that) {\n    return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;\n  }\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  add(that) {\n    const x = Math.min(this.x, that.x);\n    const y = Math.min(this.y, that.y);\n    const x2 = Math.max(this.x2, that.x + that.width);\n    const y2 = Math.max(this.y2, that.y + that.height);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n  addPoint(p) {\n    const x = Math.min(this.x, p.x);\n    const y = Math.min(this.y, p.y);\n    const x2 = Math.max(this.x2, p.x);\n    const y2 = Math.max(this.y2, p.y);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n  toString() {\n    return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;\n  }\n  draw(ctx) {\n    ctx.rect(this.x, this.y, this.width, this.height);\n  }\n  containsPt(px, py) {\n    return px >= this.x && px <= this.x2 && py >= this.y && py <= this.y2;\n  }\n  get area() {\n    return this.width * this.height;\n  }\n  intersects(that) {\n    if (this.area <= 0 || that.width <= 0 || that.height <= 0) {\n      return false;\n    }\n    return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;\n  }\n  distSquare(tempX, tempY) {\n    if (this.containsPt(tempX, tempY)) {\n      return 0;\n    }\n    const code = outcode(this, tempX, tempY);\n    if (code.has(OUT_CODE.TOP)) {\n      if (code.has(OUT_CODE.LEFT)) {\n        return ptsDistanceSq(tempX, tempY, this.x, this.y);\n      }\n      if (code.has(OUT_CODE.RIGHT)) {\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y);\n      }\n      return (this.y - tempY) * (this.y - tempY);\n    }\n    if (code.has(OUT_CODE.BOTTOM)) {\n      if (code.has(OUT_CODE.LEFT)) {\n        return ptsDistanceSq(tempX, tempY, this.x, this.y2);\n      }\n      if (code.has(OUT_CODE.RIGHT)) {\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y2);\n      }\n      return (tempY - this.y2) * (tempY - this.y2);\n    }\n    if (code.has(OUT_CODE.LEFT)) {\n      return (this.x - tempX) * (this.x - tempX);\n    }\n    if (code.has(OUT_CODE.RIGHT)) {\n      return (tempX - this.x2) * (tempX - this.x2);\n    }\n    return 0;\n  }\n}\nfunction boundingBox(path) {\n  if (path.length === 0) {\n    return null;\n  }\n  const first = path[0];\n  const bb = new Rectangle(first.x, first.y, 0, 0);\n  for (const point of path) {\n    bb.addPoint(point);\n  }\n  return bb;\n}\n\nclass Circle {\n  constructor(cx, cy, radius) {\n    this.cx = cx;\n    this.cy = cy;\n    this.radius = radius;\n  }\n  get x() {\n    return this.cx - this.radius;\n  }\n  get x2() {\n    return this.cx + this.radius;\n  }\n  get width() {\n    return this.radius * 2;\n  }\n  get y() {\n    return this.cy - this.radius;\n  }\n  get y2() {\n    return this.cy + this.radius;\n  }\n  get height() {\n    return this.radius * 2;\n  }\n  static from(r) {\n    return new Circle(r.cx, r.cy, r.radius);\n  }\n  containsPt(x, y) {\n    return ptsDistanceSq(this.cx, this.cy, x, y) < this.radius * this.radius;\n  }\n  distSquare(tempX, tempY) {\n    const dist = ptsDistanceSq(this.cx, this.cy, tempX, tempY);\n    if (dist < this.radius * this.radius) {\n      return 0;\n    }\n    const offset = Math.sqrt(dist) - this.radius;\n    return offset * offset;\n  }\n  draw(ctx) {\n    ctx.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);\n  }\n}\n\nclass Area {\n  constructor(pixelGroup, i = 0, j = 0, pixelX = 0, pixelY = 0, width, height, pixels = new Float32Array(Math.max(0, width * height)).fill(0)) {\n    this.pixelGroup = pixelGroup;\n    this.i = i;\n    this.j = j;\n    this.pixelX = pixelX;\n    this.pixelY = pixelY;\n    this.width = width;\n    this.height = height;\n    this.area = pixels;\n  }\n  createSub(rect, pixelPos) {\n    return new Area(this.pixelGroup, rect.x, rect.y, pixelPos.x, pixelPos.y, rect.width, rect.height);\n  }\n  static fromPixelRegion(pixelRect, pixelGroup) {\n    return new Area(pixelGroup, 0, 0, pixelRect.x, pixelRect.y, Math.ceil(pixelRect.width / pixelGroup), Math.ceil(pixelRect.height / pixelGroup));\n  }\n  copy(sub, pixelPoint) {\n    return new Area(this.pixelGroup, this.scaleX(pixelPoint.x), this.scaleY(pixelPoint.y), pixelPoint.x, pixelPoint.y, sub.width, sub.height, sub.area);\n  }\n  boundX(pos) {\n    if (pos < this.i) {\n      return this.i;\n    }\n    if (pos >= this.width) {\n      return this.width - 1;\n    }\n    return pos;\n  }\n  boundY(pos) {\n    if (pos < this.j) {\n      return this.j;\n    }\n    if (pos >= this.height) {\n      return this.height - 1;\n    }\n    return pos;\n  }\n  scaleX(pixel) {\n    return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));\n  }\n  scaleY(pixel) {\n    return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));\n  }\n  scale(pixelRect) {\n    const x = this.scaleX(pixelRect.x);\n    const y = this.scaleY(pixelRect.y);\n    const x2 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));\n    const y2 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n  invertScaleX(v) {\n    return Math.round(v * this.pixelGroup + this.pixelX);\n  }\n  invertScaleY(v) {\n    return Math.round(v * this.pixelGroup + this.pixelY);\n  }\n  addPadding(rect, pixelPadding) {\n    const padding = Math.ceil(pixelPadding / this.pixelGroup);\n    const x = this.boundX(rect.x - padding);\n    const y = this.boundY(rect.y - padding);\n    const x2 = this.boundX(rect.x2 + padding);\n    const y2 = this.boundY(rect.y2 + padding);\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n  get(i, j) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return Number.NaN;\n    }\n    return this.area[i + j * this.width];\n  }\n  inc(i, j, v) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] += v;\n  }\n  set(i, j, v) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] = v;\n  }\n  incArea(sub, factor) {\n    if (sub.width <= 0 || sub.height <= 0 || factor === 0) {\n      return;\n    }\n    const w = this.width;\n    const aw = sub.width;\n    const i1 = Math.max(0, sub.i);\n    const j1 = Math.max(0, sub.j);\n    const i2 = Math.min(sub.i + sub.width, w);\n    const j2 = Math.min(sub.j + sub.height, this.height);\n    if (j2 <= 0 || i2 <= 0 || i1 >= w || j2 >= this.height) {\n      return;\n    }\n    for (let j = j1; j < j2; j++) {\n      const subRow = (j - sub.j) * aw;\n      const row = j * w;\n      for (let i = i1; i < i2; i++) {\n        const v = sub.area[i - sub.i + subRow];\n        if (v === 0) {\n          continue;\n        }\n        this.area[i + row] += factor * v;\n      }\n    }\n  }\n  fill(value) {\n    this.area.fill(value);\n  }\n  fillArea(rect, value) {\n    const offset = rect.x + rect.y * this.width;\n    for (let j = 0; j < rect.height; j++) {\n      const pos = offset + j * this.width;\n      this.area.fill(value, pos, pos + rect.width);\n    }\n  }\n  fillHorizontalLine(i, j, width, value) {\n    const offset = i + j * this.width;\n    this.area.fill(value, offset, offset + width);\n  }\n  fillVerticalLine(i, j, height, value) {\n    const offset = i + j * this.width;\n    for (let i = 0; i < height; i++) {\n      this.area[offset + i * this.width] = value;\n    }\n  }\n  clear() {\n    this.area.fill(0);\n  }\n  toString() {\n    let r = '';\n    for (let j = 0; j < this.height; j++) {\n      const row = j * this.width;\n      for (let i = 0; i < this.width; i++) {\n        const v = this.area[row + i];\n        r += v.toFixed(1).padStart(6);\n        r += ' ';\n      }\n      r += '\\n';\n    }\n    return r;\n  }\n  draw(ctx, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    const min = this.area.reduce((acc, v) => Math.min(acc, v), Number.POSITIVE_INFINITY);\n    const max = this.area.reduce((acc, v) => Math.max(acc, v), Number.NEGATIVE_INFINITY);\n    const scale = v => (v - min) / (max - min);\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = `rgba(0, 0, 0, ${scale(v)})`;\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n  drawThreshold(ctx, threshold, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = v > threshold ? 'black' : 'white';\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n}\n\nfunction addPadding(r, padding) {\n  const map = r => ({\n    x: r.x - padding,\n    y: r.y - padding,\n    width: r.width + 2 * padding,\n    height: r.height + 2 * padding\n  });\n  if (Array.isArray(r)) {\n    return r.map(map);\n  }\n  return map(r);\n}\n\nfunction createLineInfluenceArea(line, potentialArea, padding) {\n  return createGenericInfluenceArea(Object.assign(lineBoundingBox(line), {\n    distSquare: (x, y) => linePtSegDistSq(line.x1, line.y1, line.x2, line.y2, x, y)\n  }), potentialArea, padding);\n}\nfunction createGenericInfluenceArea(shape, potentialArea, padding) {\n  const lr = addPadding(shape, padding);\n  const scaled = potentialArea.scale(lr);\n  const area = potentialArea.createSub(scaled, lr);\n  sample(area, potentialArea, padding, (x, y) => shape.distSquare(x, y));\n  return area;\n}\nfunction sample(area, potentialArea, padding, distanceFunction) {\n  const padding2 = padding * padding;\n  for (let y = 0; y < area.height; y++) {\n    for (let x = 0; x < area.width; x++) {\n      const tempX = potentialArea.invertScaleX(area.i + x);\n      const tempY = potentialArea.invertScaleY(area.j + y);\n      const distanceSq = distanceFunction(tempX, tempY);\n      if (distanceSq === 0) {\n        area.set(x, y, padding2);\n        continue;\n      }\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        area.set(x, y, dr * dr);\n      }\n    }\n  }\n  return area;\n}\nfunction createRectangleInfluenceArea(rect, potentialArea, padding) {\n  const scaled = potentialArea.scale(rect);\n  const padded = potentialArea.addPadding(scaled, padding);\n  const area = potentialArea.createSub(padded, {\n    x: rect.x - padding,\n    y: rect.y - padding\n  });\n  const paddingLeft = scaled.x - padded.x;\n  const paddingTop = scaled.y - padded.y;\n  const paddingRight = padded.x2 - scaled.x2;\n  const paddingBottom = padded.y2 - scaled.y2;\n  const innerWidth = padded.width - paddingLeft - paddingRight;\n  const innerHeight = padded.height - paddingTop - paddingBottom;\n  const padding2 = padding * padding;\n  area.fillArea({\n    x: paddingLeft,\n    y: paddingTop,\n    width: innerWidth + 1,\n    height: innerHeight + 1\n  }, padding2);\n  const straightDistances = [0];\n  const maxPadding = Math.max(paddingTop, paddingLeft, paddingRight, paddingBottom);\n  const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);\n  for (let i = 1; i < maxPadding; i++) {\n    const tempY = potentialArea.invertScaleY(scaled.y - i);\n    const distanceSq = rect.distSquare(tempX, tempY);\n    if (distanceSq < padding2) {\n      const dr = padding - Math.sqrt(distanceSq);\n      straightDistances.push(dr * dr);\n    } else {\n      break;\n    }\n  }\n  const cornerDistances = [];\n  const maxHorizontalPadding = Math.max(paddingLeft, paddingRight);\n  const maxVerticalPadding = Math.max(paddingTop, paddingRight);\n  for (let i = 1; i < maxHorizontalPadding; i++) {\n    const tempX = potentialArea.invertScaleX(scaled.x - i);\n    const row = [];\n    for (let j = 1; j < maxVerticalPadding; j++) {\n      const tempY = potentialArea.invertScaleY(scaled.y - j);\n      const distanceSq = rect.distSquare(tempX, tempY);\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        row.push(dr * dr);\n      } else {\n        row.push(0);\n      }\n    }\n    cornerDistances.push(row);\n  }\n  for (let y = 1; y < Math.min(paddingTop, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop - y, innerWidth + 1, value);\n  }\n  for (let y = 1; y < Math.min(paddingBottom, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop + innerHeight + y, innerWidth + 1, value);\n  }\n  for (let x = 1; x < Math.min(paddingLeft, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft - x, paddingTop, innerHeight + 1, value);\n  }\n  for (let x = 1; x < Math.min(paddingBottom, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft + innerWidth + x, paddingTop, innerHeight + 1, value);\n  }\n  for (let i = 1; i < paddingLeft; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft - i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n  for (let i = 1; i < paddingRight; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft + innerWidth + i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n  return area;\n}\n\nfunction rect(x, y, width, height) {\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction circle(cx, cy, radius) {\n  return {\n    cx,\n    cy,\n    radius\n  };\n}\nfunction line(x1, y1, x2, y2) {\n  return {\n    x1,\n    y1,\n    x2,\n    y2\n  };\n}\nfunction point(x, y) {\n  return {\n    x,\n    y\n  };\n}\n\nfunction calculateVirtualEdges(items, nonMembers, maxRoutingIterations, morphBuffer) {\n  if (items.length === 0) {\n    return [];\n  }\n  const sorted = sortByDistanceToCentroid(items);\n  return sorted.map((d, i) => {\n    const visited = sorted.slice(0, i);\n    return connectItem(nonMembers, d, visited, maxRoutingIterations, morphBuffer);\n  }).flat();\n}\nfunction connectItem(nonMembers, item, visited, maxRoutingIterations, morphBuffer) {\n  const itemCenter = point(item.cx, item.cy);\n  const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);\n  if (closestNeighbor == null) {\n    return [];\n  }\n  const directLine = new Line(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);\n  const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  return mergeLines(scannedLines, nonMembers);\n}\nfunction computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  const scannedLines = [];\n  const linesToCheck = [];\n  linesToCheck.push(directLine);\n  let hasIntersection = true;\n  for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {\n    hasIntersection = false;\n    while (!hasIntersection && linesToCheck.length > 0) {\n      const line = linesToCheck.pop();\n      const closestItem = getCenterItem(nonMembers, line);\n      const intersections = closestItem ? testIntersection(line, closestItem) : null;\n      if (!closestItem || !intersections || intersections.count !== 2) {\n        if (!hasIntersection) {\n          scannedLines.push(line);\n        }\n        continue;\n      }\n      let tempMorphBuffer = morphBuffer;\n      let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n      let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      let pointInside = isPointInRectangles(movePoint, nonMembers);\n      while (!foundFirst && pointInside && tempMorphBuffer >= 1) {\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n        foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n      if (movePoint && !foundFirst && !pointInside) {\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        hasIntersection = true;\n      }\n      if (hasIntersection) {\n        continue;\n      }\n      tempMorphBuffer = morphBuffer;\n      movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n      let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      pointInside = isPointInRectangles(movePoint, nonMembers);\n      while (!foundSecond && pointInside && tempMorphBuffer >= 1) {\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n        foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n      if (movePoint && !foundSecond) {\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        hasIntersection = true;\n      }\n      if (!hasIntersection) {\n        scannedLines.push(line);\n      }\n    }\n  }\n  while (linesToCheck.length > 0) {\n    scannedLines.push(linesToCheck.pop());\n  }\n  return scannedLines;\n}\nfunction mergeLines(scannedLines, nonMembers) {\n  const finalRoute = [];\n  while (scannedLines.length > 0) {\n    const line1 = scannedLines.pop();\n    if (scannedLines.length === 0) {\n      finalRoute.push(line1);\n      break;\n    }\n    const line2 = scannedLines.pop();\n    const mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n    const closestItem = getCenterItem(nonMembers, mergeLine);\n    if (!closestItem) {\n      scannedLines.push(mergeLine);\n    } else {\n      finalRoute.push(line1);\n      scannedLines.push(line2);\n    }\n  }\n  return finalRoute;\n}\nfunction calculateClosestNeighbor(itemCenter, visited, nonMembers) {\n  let minLengthSq = Number.POSITIVE_INFINITY;\n  return visited.reduce((closestNeighbor, neighborItem) => {\n    const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n    if (distanceSq > minLengthSq) {\n      return closestNeighbor;\n    }\n    const directLine = new Line(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n    const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);\n    if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {\n      closestNeighbor = neighborItem;\n      minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);\n    }\n    return closestNeighbor;\n  }, null);\n}\nfunction sortByDistanceToCentroid(items) {\n  if (items.length < 2) {\n    return items;\n  }\n  let totalX = 0;\n  let totalY = 0;\n  items.forEach(item => {\n    totalX += item.cx;\n    totalY += item.cy;\n  });\n  totalX /= items.length;\n  totalY /= items.length;\n  return items.map(item => {\n    const diffX = totalX - item.cx;\n    const diffY = totalY - item.cy;\n    const dist = diffX * diffX + diffY * diffY;\n    return [item, dist];\n  }).sort((a, b) => a[1] - b[1]).map(d => d[0]);\n}\nfunction isPointInRectangles(point, rects) {\n  return rects.some(r => r.containsPt(point.x, point.y));\n}\nfunction pointExists(pointToCheck, lines) {\n  return lines.some(checkEndPointsLine => {\n    if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    return false;\n  });\n}\nfunction getCenterItem(items, testLine) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let closestItem = null;\n  for (const item of items) {\n    if (!intersectsLine(item, testLine)) {\n      continue;\n    }\n    const distance = fractionToLineCenter(item, testLine);\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  }\n  return closestItem;\n}\nfunction itemsCuttingLine(items, testLine) {\n  return items.reduce((count, item) => {\n    if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {\n      return count + 1;\n    }\n    return count;\n  }, 0);\n}\nfunction rerouteLine(item, rerouteBuffer, intersections, wrapNormal) {\n  const topIntersect = intersections.top;\n  const leftIntersect = intersections.left;\n  const bottomIntersect = intersections.bottom;\n  const rightIntersect = intersections.right;\n  if (wrapNormal) {\n    if (leftIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT)\n        return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT)\n        return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      const totalArea = item.width * item.height;\n      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n      if (topArea < totalArea * 0.5) {\n        if (leftIntersect.y > rightIntersect.y)\n          return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n        return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      }\n      if (leftIntersect.y < rightIntersect.y)\n        return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (rightIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT)\n        return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT)\n        return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    const totalArea = item.height * item.width;\n    const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n    if (leftArea < totalArea * 0.5) {\n      if (topIntersect.x > bottomIntersect.x)\n        return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (topIntersect.x < bottomIntersect.x)\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n  }\n  if (leftIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT)\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT)\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    const totalArea = item.height * item.width;\n    const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y)\n        return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (leftIntersect.y < rightIntersect.y)\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  if (rightIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT)\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT)\n      return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  const totalArea = item.height * item.width;\n  const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x)\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n  }\n  if (topIntersect.x < bottomIntersect.x)\n    return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n  return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n}\n\nfunction canTakeNext(path, start, end, toleranceSquared) {\n  const validEnd = path.closed ? end < path.length : end < path.length - 1;\n  if (!validEnd) {\n    return false;\n  }\n  const s = path.get(start);\n  const e = path.get(end + 1);\n  for (let index = start + 1; index <= end; index++) {\n    const p = path.get(index);\n    const len = linePtSegDistSq(s.x, s.y, e.x, e.y, p.x, p.y);\n    if (len > toleranceSquared) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shapeSimplifier(tolerance = 0.0) {\n  return path => {\n    if (tolerance < 0 || path.length < 3) {\n      return path;\n    }\n    const points = [];\n    let start = 0;\n    const toleranceSquared = tolerance * tolerance;\n    while (start < path.length) {\n      let end = start + 1;\n      while (canTakeNext(path, start, end, toleranceSquared)) {\n        end++;\n      }\n      points.push(path.get(start));\n      start = end;\n    }\n    return new PointPath(points);\n  };\n}\n\nfunction basicFunction(i, t) {\n  switch (i) {\n    case -2:\n      return (((-t + 3.0) * t - 3.0) * t + 1.0) / 6.0;\n    case -1:\n      return ((3.0 * t - 6.0) * t * t + 4.0) / 6.0;\n    case 0:\n      return (((-3.0 * t + 3.0) * t + 3.0) * t + 1.0) / 6.0;\n    case 1:\n      return t * t * t / 6.0;\n    default:\n      throw new Error('unknown error');\n  }\n}\nfunction bSplineShapeGenerator(granularity = 6.0) {\n  const ORDER = 3;\n  const START_INDEX = ORDER - 1;\n  const REL_END = 1;\n  const REL_START = REL_END - ORDER;\n  function calcPoint(path, i, t) {\n    let px = 0.0;\n    let py = 0.0;\n    for (let j = REL_START; j <= REL_END; j++) {\n      const p = path.get(i + j);\n      const bf = basicFunction(j, t);\n      px += bf * p.x;\n      py += bf * p.y;\n    }\n    return {\n      x: px,\n      y: py\n    };\n  }\n  return path => {\n    if (path.length < 3) {\n      return path;\n    }\n    const res = [];\n    const closed = path.closed;\n    const count = path.length + ORDER - 1 + (closed ? 0 : 2);\n    res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));\n    for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {\n      for (let k = 1; k <= granularity; k++) {\n        res.push(calcPoint(path, ix, k / granularity));\n      }\n    }\n    return new PointPath(res);\n  };\n}\n\nfunction samplePath(skip = 8) {\n  return path => {\n    let actSkip = skip;\n    let size = path.length;\n    if (actSkip > 1) {\n      size = Math.floor(path.length / actSkip);\n      while (size < 3 && actSkip > 1) {\n        actSkip -= 1;\n        size = Math.floor(path.length / actSkip);\n      }\n    }\n    const finalHull = [];\n    for (let i = 0, j = 0; j < size; j++, i += actSkip) {\n      finalHull.push(path.get(i));\n    }\n    return new PointPath(finalHull);\n  };\n}\n\nclass PointPath {\n  constructor(points = [], closed = true) {\n    this.points = points;\n    this.closed = closed;\n  }\n  get(index) {\n    let i = index;\n    const l = this.points.length;\n    if (index < 0) {\n      return this.closed ? this.get(index + l) : this.points[0];\n    } else if (index >= l) {\n      return this.closed ? this.get(index - l) : this.points[l - 1];\n    }\n    return this.points[i];\n  }\n  get length() {\n    return this.points.length;\n  }\n  toString(roundToDigits = Infinity) {\n    const points = this.points;\n    if (points.length === 0) {\n      return '';\n    }\n    const rounder = typeof roundToDigits === 'function' ? roundToDigits : round(roundToDigits);\n    let r = 'M';\n    for (const p of points) {\n      r += `${rounder(p.x)},${rounder(p.y)} L`;\n    }\n    r = r.slice(0, -1);\n    if (this.closed) {\n      r += ' Z';\n    }\n    return r;\n  }\n  draw(ctx) {\n    const points = this.points;\n    if (points.length === 0) {\n      return;\n    }\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (const p of points) {\n      ctx.lineTo(p.x, p.y);\n    }\n    if (this.closed) {\n      ctx.closePath();\n    }\n  }\n  sample(skip) {\n    return samplePath(skip)(this);\n  }\n  simplify(tolerance) {\n    return shapeSimplifier(tolerance)(this);\n  }\n  bSplines(granularity) {\n    return bSplineShapeGenerator(granularity)(this);\n  }\n  apply(transformer) {\n    return transformer(this);\n  }\n  containsElements(members) {\n    const bb = boundingBox(this.points);\n    if (!bb) {\n      return false;\n    }\n    return members.every(member => {\n      return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);\n    });\n  }\n  withinArea(px, py) {\n    if (this.length === 0) {\n      return false;\n    }\n    let crossings = 0;\n    const first = this.points[0];\n    const line = new Line(first.x, first.y, first.x, first.y);\n    for (let i = 1; i < this.points.length; i++) {\n      const cur = this.points[i];\n      line.x1 = line.x2;\n      line.y1 = line.y2;\n      line.x2 = cur.x;\n      line.y2 = cur.y;\n      if (line.cuts(px, py)) {\n        crossings++;\n      }\n    }\n    line.x1 = line.x2;\n    line.y1 = line.y2;\n    line.x2 = first.x;\n    line.y2 = first.y;\n    if (line.cuts(px, py)) {\n      crossings++;\n    }\n    return crossings % 2 == 1;\n  }\n}\n\nclass PointList {\n  constructor(size = 0) {\n    this.count = 0;\n    this.arr = [];\n    this.set = new Set();\n    this.arr.length = size;\n  }\n  add(p) {\n    this.set.add(`${p.x}x${p.y}`);\n    this.arr[this.count++] = p;\n  }\n  contains(p) {\n    return this.set.has(`${p.x}x${p.y}`);\n  }\n  isFirst(p) {\n    if (this.count === 0) {\n      return false;\n    }\n    const o = this.arr[0];\n    return o != null && o.x === p.x && o.y === p.y;\n  }\n  path() {\n    return new PointPath(this.arr.slice(0, this.count));\n  }\n  clear() {\n    this.set.clear();\n    this.count = 0;\n  }\n  get(ix) {\n    return this.arr[ix];\n  }\n  get length() {\n    return this.count;\n  }\n}\n\nconst N = 0;\nconst S = 1;\nconst E = 2;\nconst W = 3;\nfunction marchingSquares(potentialArea, threshold) {\n  const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;\n  const contour = new PointList(estLength);\n  function updateDir(x, y, dir, res) {\n    const v = potentialArea.get(x, y);\n    if (Number.isNaN(v)) {\n      return Number.NaN;\n    }\n    if (v > threshold) {\n      return dir + res;\n    }\n    return dir;\n  }\n  function getState(x, y) {\n    let dir = N;\n    dir = updateDir(x, y, dir, 1);\n    dir = updateDir(x + 1, y, dir, 2);\n    dir = updateDir(x, y + 1, dir, 4);\n    dir = updateDir(x + 1, y + 1, dir, 8);\n    if (Number.isNaN(dir)) {\n      return -1;\n    }\n    return dir;\n  }\n  let direction = S;\n  function doMarch(xPos, yPos) {\n    let x = xPos;\n    let y = yPos;\n    let xPixel = potentialArea.invertScaleX(x);\n    let yPixel = potentialArea.invertScaleY(y);\n    for (let i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      const p = {\n        x: xPixel,\n        y: yPixel\n      };\n      if (contour.contains(p)) {\n        if (!contour.isFirst(p)) ; else {\n          return true;\n        }\n      } else {\n        contour.add(p);\n      }\n      const state = getState(x, y);\n      switch (state) {\n        case -1:\n          return true;\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          direction = E;\n          break;\n        case 12:\n        case 14:\n        case 4:\n          direction = W;\n          break;\n        case 6:\n          direction = direction == N ? W : E;\n          break;\n        case 1:\n        case 13:\n        case 5:\n          direction = N;\n          break;\n        case 9:\n          direction = direction == E ? N : S;\n          break;\n        case 10:\n        case 8:\n        case 11:\n          direction = S;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n      switch (direction) {\n        case N:\n          y--;\n          yPixel -= potentialArea.pixelGroup;\n          break;\n        case S:\n          y++;\n          yPixel += potentialArea.pixelGroup;\n          break;\n        case W:\n          x--;\n          xPixel -= potentialArea.pixelGroup;\n          break;\n        case E:\n          x++;\n          xPixel += potentialArea.pixelGroup;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n    }\n    return true;\n  }\n  for (let x = 0; x < potentialArea.width; x++) {\n    for (let y = 0; y < potentialArea.height; y++) {\n      if (potentialArea.get(x, y) <= threshold) {\n        continue;\n      }\n      const state = getState(x, y);\n      if (state < 0 || state === 15) {\n        continue;\n      }\n      if (doMarch(x, y)) {\n        return contour.path();\n      }\n    }\n  }\n  return null;\n}\n\nconst defaultOptions = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 20,\n  pixelGroup: 4,\n  edgeR0: 10,\n  edgeR1: 20,\n  nodeR0: 15,\n  nodeR1: 50,\n  morphBuffer: 10,\n  threshold: 1,\n  memberInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  nonMemberInfluenceFactor: -0.8,\n  virtualEdges: true\n};\nfunction isCircle(v) {\n  return v != null && typeof v.radius === 'number';\n}\nfunction isEqual(a, b) {\n  if (isCircle(a) !== isCircle(b)) {\n    return false;\n  }\n  if (isCircle(a)) {\n    const bc = b;\n    return a.cx === bc.cx && a.cy === bc.cy && a.radius === bc.radius;\n  }\n  const br = b;\n  return a.x === br.x && a.y === br.y && a.width === br.width && a.height === br.height;\n}\nvar EDirty;\n(function (EDirty) {\n  EDirty[EDirty[\"MEMBERS\"] = 0] = \"MEMBERS\";\n  EDirty[EDirty[\"NON_MEMBERS\"] = 1] = \"NON_MEMBERS\";\n  EDirty[EDirty[\"EDGES\"] = 2] = \"EDGES\";\n})(EDirty || (EDirty = {}));\nclass BubbleSets {\n  constructor(options = {}) {\n    this.dirty = new Set();\n    this.members = [];\n    this.nonMembers = [];\n    this.virtualEdges = [];\n    this.edges = [];\n    this.activeRegion = new Rectangle(0, 0, 0, 0);\n    this.potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);\n    this.o = Object.assign({}, defaultOptions, options);\n  }\n  pushMember(...members) {\n    if (members.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.MEMBERS);\n    for (const v of members) {\n      this.members.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null\n      });\n    }\n  }\n  removeMember(member) {\n    const index = this.members.findIndex(d => isEqual(d.raw, member));\n    if (index < 0) {\n      return false;\n    }\n    this.members.splice(index, 1);\n    this.dirty.add(EDirty.MEMBERS);\n    return true;\n  }\n  removeNonMember(nonMember) {\n    const index = this.nonMembers.findIndex(d => isEqual(d.raw, nonMember));\n    if (index < 0) {\n      return false;\n    }\n    this.nonMembers.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n  removeEdge(edge) {\n    const index = this.edges.findIndex(d => d.obj.equals(edge));\n    if (index < 0) {\n      return false;\n    }\n    this.edges.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n  pushNonMember(...nonMembers) {\n    if (nonMembers.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.NON_MEMBERS);\n    for (const v of nonMembers) {\n      this.nonMembers.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null\n      });\n    }\n  }\n  pushEdge(...edges) {\n    if (edges.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.EDGES);\n    for (const v of edges) {\n      this.edges.push({\n        raw: v,\n        obj: Line.from(v),\n        area: null\n      });\n    }\n  }\n  update() {\n    const dirtyMembers = this.dirty.has(EDirty.MEMBERS);\n    const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);\n    let dirtyEdges = this.dirty.has(EDirty.EDGES);\n    this.dirty.clear();\n    const memberObjs = this.members.map(d => d.obj);\n    if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {\n      const nonMembersAsRects = this.nonMembers.map(d => d.obj);\n      const virtualEdges = calculateVirtualEdges(memberObjs, nonMembersAsRects, this.o.maxRoutingIterations, this.o.morphBuffer);\n      const old = new Map(this.virtualEdges.map(e => [e.obj.toString(), e.area]));\n      this.virtualEdges = virtualEdges.map(e => {\n        var _old$get;\n        return {\n          raw: e,\n          obj: e,\n          area: (_old$get = old.get(e.toString())) !== null && _old$get !== void 0 ? _old$get : null\n        };\n      });\n      dirtyEdges = true;\n    }\n    let activeRegionDirty = false;\n    if (dirtyMembers || dirtyEdges) {\n      const edgesObj = this.virtualEdges.concat(this.edges).map(e => e.obj);\n      const bb = unionBoundingBox(memberObjs, edgesObj);\n      const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;\n      const activeRegion = Rectangle.from(addPadding(bb, padding));\n      if (!activeRegion.equals(this.activeRegion)) {\n        activeRegionDirty = true;\n        this.activeRegion = activeRegion;\n      }\n    }\n    if (activeRegionDirty) {\n      const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);\n      const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);\n      if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n        this.members.forEach(m => m.area = null);\n        this.nonMembers.forEach(m => m.area = null);\n        this.edges.forEach(m => m.area = null);\n        this.virtualEdges.forEach(m => m.area = null);\n      } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n      }\n    }\n    const existing = new Map();\n    const addCache = m => {\n      if (m.area) {\n        const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n        existing.set(key, m.area);\n      }\n    };\n    const createOrAddCache = m => {\n      if (m.area) {\n        return;\n      }\n      const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n      if (existing.has(key)) {\n        const r = existing.get(key);\n        m.area = this.potentialArea.copy(r, {\n          x: m.obj.x - this.o.nodeR1,\n          y: m.obj.y - this.o.nodeR1\n        });\n        return;\n      }\n      const r = m.obj instanceof Rectangle ? createRectangleInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1) : createGenericInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1);\n      m.area = r;\n      existing.set(key, r);\n    };\n    this.members.forEach(addCache);\n    this.nonMembers.forEach(addCache);\n    this.members.forEach(createOrAddCache);\n    this.nonMembers.forEach(m => {\n      if (!this.activeRegion.intersects(m.obj)) {\n        m.area = null;\n      } else {\n        createOrAddCache(m);\n      }\n    });\n    this.edges.forEach(edge => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n    this.virtualEdges.forEach(edge => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n  }\n  drawMembers(ctx) {\n    for (const member of this.members) {\n      member.obj.draw(ctx);\n    }\n  }\n  drawNonMembers(ctx) {\n    for (const member of this.nonMembers) {\n      member.obj.draw(ctx);\n    }\n  }\n  drawEdges(ctx) {\n    for (const edge of this.edges) {\n      edge.obj.draw(ctx);\n    }\n  }\n  drawPotentialArea(ctx, offset = true) {\n    this.potentialArea.draw(ctx, offset);\n  }\n  compute() {\n    if (this.members.length === 0) {\n      return new PointPath([]);\n    }\n    if (this.dirty.size > 0) {\n      this.update();\n    }\n    const {\n      o,\n      potentialArea\n    } = this;\n    const members = this.members.map(m => m.area);\n    const edges = this.virtualEdges.concat(this.edges).map(d => d.area);\n    const nonMembers = this.nonMembers.filter(d => d.area != null).map(d => d.area);\n    const memberObjs = this.members.map(m => m.obj);\n    return calculatePotentialOutline(potentialArea, members, edges, nonMembers, p => p.containsElements(memberObjs), o);\n  }\n}\nfunction calculatePotentialOutline(potentialArea, members, edges, nonMembers, validPath, options = {}) {\n  const o = Object.assign({}, defaultOptions, options);\n  let threshold = o.threshold;\n  let memberInfluenceFactor = o.memberInfluenceFactor;\n  let edgeInfluenceFactor = o.edgeInfluenceFactor;\n  let nonMemberInfluenceFactor = o.nonMemberInfluenceFactor;\n  const nodeInfA = (o.nodeR0 - o.nodeR1) * (o.nodeR0 - o.nodeR1);\n  const edgeInfA = (o.edgeR0 - o.edgeR1) * (o.edgeR0 - o.edgeR1);\n  for (let iterations = 0; iterations < o.maxMarchingIterations; iterations++) {\n    potentialArea.clear();\n    if (memberInfluenceFactor !== 0) {\n      const f = memberInfluenceFactor / nodeInfA;\n      for (const item of members) {\n        potentialArea.incArea(item, f);\n      }\n    }\n    if (edgeInfluenceFactor !== 0) {\n      const f = edgeInfluenceFactor / edgeInfA;\n      for (const area of edges) {\n        potentialArea.incArea(area, f);\n      }\n    }\n    if (nonMemberInfluenceFactor !== 0) {\n      const f = nonMemberInfluenceFactor / nodeInfA;\n      for (const area of nonMembers) {\n        potentialArea.incArea(area, f);\n      }\n    }\n    const contour = marchingSquares(potentialArea, threshold);\n    if (contour && validPath(contour)) {\n      return contour;\n    }\n    threshold *= 0.95;\n    if (iterations <= o.maxMarchingIterations * 0.5) {\n      memberInfluenceFactor *= 1.2;\n      edgeInfluenceFactor *= 1.2;\n    } else if (nonMemberInfluenceFactor != 0 && nonMembers.length > 0) {\n      nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n  return new PointPath([]);\n}\nfunction unionBoundingBox(memberItems, edgeItems) {\n  if (memberItems.length === 0) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  const activeRegion = Rectangle.from(memberItems[0]);\n  for (const m of memberItems) {\n    activeRegion.add(m);\n  }\n  for (const l of edgeItems) {\n    activeRegion.add(lineBoundingBox(l));\n  }\n  return activeRegion;\n}\nfunction createOutline(members, nonMembers = [], edges = [], options = {}) {\n  if (members.length === 0) {\n    return new PointPath([]);\n  }\n  const bb = new BubbleSets(options);\n  bb.pushMember(...members);\n  bb.pushNonMember(...nonMembers);\n  bb.pushEdge(...edges);\n  return bb.compute();\n}\n\nexport default BubbleSets;\nexport { Area, BubbleSets, Circle, Line, PointPath, Rectangle, addPadding, boundingBox, calculatePotentialOutline, calculateVirtualEdges, circle, createGenericInfluenceArea, createLineInfluenceArea, createOutline, createRectangleInfluenceArea, defaultOptions, line, lineBoundingBox, point, rect, unionBoundingBox };\n//# sourceMappingURL=bubblesets.esm.js.map\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n",null,null,null],"names":["__classPrivateFieldGet","receiver","privateMap","has","TypeError","get","__classPrivateFieldSet","value","set","linePtSegDistSq","lx1","ly1","lx2","ly2","x","y","x2","y2","px","py","dotprod","projlenSq","lenSq","ptsDistanceSq","x1","y1","doublePointsEqual","delta","digits","Number","v","Math","round","factor","FUNC_ERROR_TEXT","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","freeGlobal","global","Object","freeSelf","self","root","Function","objectToString","prototype","toString","nativeMax","max","nativeMin","min","now","Date","debounce","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","remainingWait","debounced","isInvoking","arguments","this","toNumber","isObject","cancel","clearTimeout","flush","type","isObjectLike","call","isSymbol","other","valueOf","replace","isBinary","test","slice","round2","SCRATCH_KEY","circularBase","circular","Set","concat","map","toNodeKey","data","shape","width","height","isCircle","toEdgeKey","line","createShape","bb","Circle","w","h","Rectangle","BubbleSetPath","[object Object]","adapter","node","nodes","edges","avoidNodes","_activeArea","_potentialArea","Area","_options","_virtualEdgeAreas","Map","_throttledUpdate","_adder","_remover","_adapter","union","boundingBox","potentialAreaDirty","padding","edgeR1","nodeR1","morphBuffer","nextPotentialBB","fromPixelRegion","pixelGroup","potentialArea","cache","forEach","n","scratch","area","updateEdges","updateNodeData","style","copy","key","createGenericInfluenceArea","createRectangleInfluenceArea","members","nonMembers","edgeCache","lines","i","areas","updateEdgeArea","r","createLineInfluenceArea","e","ps","segmentPoints","sourceEndpoint","targetEndpoint","d","assign","length","next","prev","Line","from","a","b","every","ai","push","memberShapes","virtualEdges","nonMembersShapes","calculateVirtualEdges","maxRoutingIterations","clear","memberAreas","nonMemberAreas","path","calculatePotentialOutline","p","containsElements","setAttribute","sample","simplify","bSplines","defaultOptions","stroke","fill","fillOpacity","className","throttle","interactive","includeLabels","includeMainLabels","includeOverlays","includeSourceLabels","includeTargetLabels","classList","add","addEventListener","select","update","target","on","off","remove","BubbleSetsPlugin","cy","_layers","index","indexOf","splice","_cy","layer","layers","nodeLayer","insertBefore","collection","ownerDocument","createElementNS","appendChild","bubbleSets","register","cytoscape","window"],"mappings":"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"}